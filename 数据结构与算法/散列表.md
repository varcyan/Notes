# 散列表

散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash 表”

## 散列思想

散列表用的是数组支持按照下标随机访问数据(时间复杂度是O(1))的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。

通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

- 键（key）关键字
- 散列函数：映射方法
- 散列值（hash值）：散列函数计算得到的值
[](https://static001.geekbang.org/resource/image/92/73/92c89a57e21f49d2f14f4424343a2773.jpg?wh=1142*744)

## 散列函数

`hash(key)`

```
function hash(key: 键): 散列值 {}
```

散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。

### 散列函数设计基本要求

1. 散列函数计算得到的值是一个非负整数
   - 数组下标从0开始
2. 如果 key1 = key2，那 hash(key1) == hash(key2)
   - 相同的key，通过散列函数得到的散列值也应该是相同的
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。
   - 不同的key，通过散列函数得到的散列值应当不同，但很难。数组存储空间有限，会加大**散列冲突**的概率。

### 如何设计好的散列函数

- 不能太复杂，过于复杂的散列函数，势必会消耗很多计算时间，影响散列表的性能。
- 散列函数生成的值要尽可能随机并且均匀分布
- 考虑综合因素：关键字的长度、特点、分布、还有散列表的大小等

## 散列冲突

再好的散列函数也无法避免散列冲突。  
常用的解决办法：

- 开放寻址法
- 链表法

### 方法

#### 开放寻址法

**核心思想**：如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。

**如何重新探测新的位置**：  

- 线性探测
- 二次探测
- 双重散列
  - 使用多个散列函数，如果使用第一个散列函数得到的存储位置被占用，再使用第二个散列函数，以此类推，直到找到空闲的存储位置

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

#### 链表法

通过散列函数计算出一样值的内容，存在同一个桶中，用链表的方式将其连接

### 装载因子

当散列表中空闲位置不多的时候，散列冲突的概率会大大提高。**装载因子**来表示空位的多少

```
散列表的装载因子=填入表中的元素个数/散列表的长度
```

装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。

#### 过大怎么办

针对散列表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。

针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。

实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。

当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。

## ？

散列表查找 ？空闲位置
