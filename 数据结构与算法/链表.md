# 链表


## 定义
**链表经典应用场景**： LRU缓存淘汰算法  

## 链表结构

**存储结构**  
数组需要一块**连续的内存空间**。  
链表通过指针将一组零散的内存块串联起来使用。内存块称为链表的“结点”。

**常见的链表结构**  
单链表、双向链表和循环链表。  

### 单链表
为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。

```
# 单链表
-> data\next -> data\next -> data\next -> null
```

有两个特殊节点：头节点、尾节点。  
**头结点**： 用来记录链表的基地址。有了它，我们就可以遍历得到整条链表  
**尾节点**：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。

#### 链表的插入和删除操作
链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。
![示例](https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg?wh=1142*650)  

#### 链表的查找工作
#### 单链表
bad: 链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。  
你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。

### 循环链表
循环链表跟单链表唯一的区别就在尾结点。  
循环链表的尾结点指针是指向链表的头结点。  
它像一个环一样首尾相连，所以叫作“循环”链表。  

**good**: 从链尾到链头比较方便。  

### 双向链表
双向链表的节点指向前后两个方向。  
```
-> prev\data\next <-> prev\data\next  <-> prev\data\next
```

#### 劣势
双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。因此储存同样多的数据，双向链表占用更多的内存空间。
#### 优势
**删除操作**  
1. 删除结点中“值等于某个给定值”的结点；
2. 删除给定指针指向的结点。

第一种，单双都需要依次遍历。  
第二种，如需要删除某节点的前驱几点，双链表不需要像单链表遍历。此时双链表的时间复杂度是O(1),单链表的时间复杂度是O(n)。  
**插入操作**  
同理

**查询**  
对于有序列表来说。双向链表的按值查询的效率也要比单链表高一些。  
因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

### 双向循环链表


### 小结
对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

## 链表 vs 数组
!(链表数组时间插入、删除、随机访问的时间复杂度)[https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg?wh=1142*449]

### 访问效率
数组使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。  
而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

### 存储空间
数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。


## 总结
在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。  
如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片。

## 练习
回文字符串   

## 技巧
### 理解指针或引用的含义
指针指向变量。
### 警惕指针丢失和内存泄漏
**插入**  
先将新节点的next指向after节点，再将before节点的next指向新节点。  
这样才不会丢失指针，导致内存泄漏。
> tips: 插入结点时，一定要注意操作的顺序
```
new_node->next = before->next;
before->next = new_node;
```
**空链表**  
```
if (head == null) {
  head = new_node;
}
```
**删除**  
```
# 不是最后一个节点的情况
p->next = p->next->next;
# 是最后一个节点？
if (head->next == null) {
   head = null;
}
```
不带头结点的链表，初始时 head 等于 null ; 带头结点的链表，初始时 head->next 等于 null ;

### 哨兵简化实现难度
解决边界问题。不直接参与业务逻辑。  
因为针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，不简洁，且容易出错。
### 重点留意边界条件处理
   1. 如果链表为空时，代码是否能正常工作？
   2. 如果链表只包含一个结点时，代码是否能正常工作？
   3. 如果链表只包含两个结点时，代码是否能正常工作？
   4. 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
### 画图OHO，释放一些脑容量~~
### 多练习
   1. 单链表反转
   2. 链表中环的检测
   3. 两个有序的链表合并
   4. 删除链表倒数第 n 个结点
   5. 求链表的中间结点
# ？
双向链表尾节点


- 涉及链表的特殊位置，考虑快慢指针
- 找到删除链表节点，找到它的前一位