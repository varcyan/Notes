# 递归

## 相关

- DFS深度优先搜索
- 前中后序二叉树遍历
  ...

## 三个条件

1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

## 如何写

1. 写出递归公式
2. 找到终止条件

### tips

- 当一个问题A分解为多个子问题时，假设多个子问题已经解决，在此基础上思考如何解决问题A
- 仅考虑问题A和子问题之间的关系即可，屏蔽掉递归细节

## 警惕

### 堆栈溢出

函数调用会使用栈保存临时变量，当递归求解数据规模很大，调用层级很深，一直压入栈，会有堆栈溢出的风险。

#### 如何避免

限制递归调用的最大深度：  

- 不能完全解决问题，最大允许递归深度与当前线程的剩余栈空间大小有关。  
- 限于最大深度比较小的时候使用此方法。

当深度过大时，使用迭非递归代码实现。

### 重复计算

使用散列表保存已经求过解的内容。

### 递归 -> 非递归

迭代循环实现。  
实际上是将递归改成了手动递归，本质没有变。并且徒增复杂度

## 小结

满足“三个条件”的问题可以通过递归解决。  

如何写：递推公式 + 终止条件  

弊端：  
空间复杂度高、有堆栈溢出的风险、重复计算、过多函数调用耗时较多
优点：  
表达力强、简洁

# ?

- DFS深度优先搜索
- 前中后序二叉树遍历
- 斐波那契数列
- 散列表
- 示例2
- 如何调试
- 拓扑排序