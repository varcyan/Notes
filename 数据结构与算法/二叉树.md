# 二叉树

- 非线性表结构 -> 树

? 什么样的二叉树适合用数组来存储： 完全二叉树



**特点**： 支持动态数据集合的快速插入、删除、查找操作。







## 树

![树](https://static001.geekbang.org/resource/image/b7/29/b7043bf29a253bb36221eaec62b2e129.jpg?wh=1142*731)

- 每个元素叫做“节点”
- 节点关系
  - 父节点
  - 子节点
  - 兄弟节点
  - 根节点：没有父节点的节点
  - 叶(子)节点：没有子节点的节点



**相关概念**

- 高度：节点到叶子节点的最长路径（边的个数）
- 深度：根节点到这个节点经历的边的个数
- 层：节点深度 + 1
- 树的高度：根节点的高度



**什么是二叉树**

> 每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。

**满二叉树**：除了叶子节点，每个节点都有左右两个子节点

**完全二叉树**：最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。



## 如何存储一颗二叉树

### 链式存储法

三个字段

- data
- left左指针
- right右指针



### 顺序存储法

![](https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg?wh=1142*604)

i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。



完全二叉树会浪费数组下标为0的位置，非完全二叉树会浪费比较多的数组存储空间。



## 遍历二叉树

- 前序遍历 -> middle - 左 - 右
- 中序遍历 -> 左 - middle - 右
- 后序遍历 ->  左 - 右 -middle



## 二叉查找树

为了实现快速查找。

**特性**

- 支持快速查找、还支持快速插入、删除一个数据
- 中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。

在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

### **查找**  

如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。

```typescript
public class BinarySearchTree {
  private Node tree;

  public Node find(int data) {
    Node p = tree;
    while (p != null) {
      if (data < p.data) p = p.left;
      else if (data > p.data) p = p.right;
      else return p;
    }
    return null;
  }

  public static class Node {
    private int data;
    private Node left;
    private Node right;

    public Node(int data) {
      this.data = data;
    }
  }
}
```

### 插入

如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。

![](https://static001.geekbang.org/resource/image/da/c5/daa9fb557726ee6183c5b80222cfc5c5.jpg?wh=1142*602)

```java
public void insert(int data) {
  if (tree == null) {
    tree = new Node(data);
    return;
  }

  Node p = tree;
  while (p != null) {
    if (data > p.data) {
      if (p.right == null) {
        p.right = new Node(data);
        return;
      }
      p = p.right;
    } else { // data < p.data
      if (p.left == null) {
        p.left = new Node(data);
        return;
      }
      p = p.left;
    }
  }
}
```

### 删除

1. 如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null

2. 如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如删除节点13

3. 如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。

   ![](https://static001.geekbang.org/resource/image/29/2c/299c615bc2e00dc32225f4d9e3490e2c.jpg?wh=1142*620)

### 快速查找最大、最小、前驱、后继节点

- 最大节点：直接向右遍历到底
- 最小节点：直接向左遍历到底
- 前驱节点：当前节点，对其左子树进行向右遍历到底
- 后继节点：当前节点，对其右子树进行向左遍历到底

## 支持重复数据的二叉查找树

**卫星数据**：在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。

key值相同时如何处理？

1. 二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
2. 把这个新插入的数据当作大于这个节点的值来处理。
   1. 查找：遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。
   2. 删除：先查找，再使用二叉查找树的删除方法，依次删除



##  平衡二叉树

> 二叉树中任意一个节点的左右子树的高度相差不能大于 1。

完全二叉树和满二叉树都是平衡二叉树。

非全玩二叉树也有可能是平衡二叉树。



**AVL树**：最先被发明的平衡二叉树。它严格符合平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。



**红黑树**并不严格符合上面的定义。



何为 **“平衡”**

发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度/性能退化的问题。

因此平衡指的是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。



### 如何定义一颗“红黑树”

- 根节点是黑色的；
- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；



**平衡**：等价为性能不退化

**近似平衡**：性能不会退化得太严重



### 小结

#### 对比

Treap\Splay Tree绝大多数情况下操作效率很高，但无法避免极端情况下的时间复杂度退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。



AVL 树是一种高度平衡的二叉树

优势：所以查找的效率非常高
劣势：为了维持高度平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。

所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。



#### 为什么选择红黑树

红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。

所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。



#### 动态数据结构

动态数据结构是支持动态的更新操作，里面存储的数据是时刻在变化的，通俗一点讲，它不仅仅支持查询，还支持删除、插入数据。而且，这些操作都非常高效。如果不高效，也就算不上是有效的动态数据结构了。所以，这里的红黑树算一个，支持动态的插入、删除、查找，而且效率都很高。链表、队列、栈实际上算不上，因为操作非常有限，查询效率不高。

## TODO
给定一组数据，比如 1，3，5，6，9，10。可以构建出多少种不同的二叉树？
