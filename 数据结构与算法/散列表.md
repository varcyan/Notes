# 散列表

散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash 表”

## 散列思想

散列表用的是数组支持按照下标随机访问数据(时间复杂度是O(1))的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。

通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

- 键（key）关键字
- 散列函数：映射方法
- 散列值（hash值）：散列函数计算得到的值
[](https://static001.geekbang.org/resource/image/92/73/92c89a57e21f49d2f14f4424343a2773.jpg?wh=1142*744)

## 散列函数

`hash(key)`

```
function hash(key: 键): 散列值 {}
```

### 散列函数设计基本要求

1. 散列函数计算得到的值是一个非负整数
   - 数组下标从0开始
2. 如果 key1 = key2，那 hash(key1) == hash(key2)
   - 相同的key，通过散列函数得到的散列值也应该是相同的
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。
   - 不同的key，通过散列函数得到的散列值应当不同，但很难。数组存储空间有限，会加大**散列冲突**的概率。

## 散列冲突

再好的散列函数也无法避免散列冲突。  
常用的解决办法：

- 开放寻址法
- 链表法

### 开放寻址法

**核心思想**：如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。

**如何重新探测新的位置**：  

- 线性探测
- 二次探测
- 双重散列
  - 使用多个散列函数，如果使用第一个散列函数得到的存储位置被占用，再使用第二个散列函数，以此类推，直到找到空闲的存储位置

**装载因子**：  
当散列表中空闲位置不多的时候，散列冲突的概率会大大提高。**装载因子**来表示空位的多少

```
散列表的装载因子=填入表中的元素个数/散列表的长度
```

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

### 链表法

## ？

散列表查找 ？空闲位置
