# 排序优化

如何实现一个通用的、高性能的排序函数？

[](https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg?wh=1142*698)

## 如何选择

如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；
如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效;
所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。

### Why not choose 归并排序

归并排序空间复杂度是O(n),对于内存占用大的数据，除了数据本身占用的内容，排序算法还需要额外占用内存空间，空间耗费翻倍。

### 如何优化快速排序

#### 分区点

分区点（privot）为最后一个数据时，最坏时间复杂度O(n^2)。因此出现最坏时间复杂度原因在于分区点选择不合理。

理想分区点：被区分的两个分区中，数据数量差不多。

##### 分区算法

- 三数取中
  - 从区间首、尾、中间分别取一个数字，对比大小，取中间值作为分区点
  - 要排序数据比较大时，可能要五数取中、十数取中
- 随机法

#### 递归

警惕堆栈溢出。

1. 限制递归深度
2. 模拟实现函数调用栈，手动模拟递归压栈。

### qsort

小规模数据（1~2k）：归并  
大规模数据（如100M）：快排  
快排过程中如果区间元素个数<=4：插入排序 小规模数据下，O(n^2)不一定比O(nlogn)运行慢

## 小结

如何实现一个高效的排序函数呢？
1.归并排序的最好最坏平均复杂度都为O(n logn),可以看出是一个稳定的排序算法，但是起空间复杂度为O(n)，基于这个特点，如果排序的数据较少也就是占用内存少的情况下，优先选择归并排序。因为不管在什么情况下复杂度都为O(n logn)，由于所需排序占用内存小，所以O(n)的空间占用也就可以忽略了。  
2.如果数据很大的话，比如说100M，如果这时还使用归并排序的话内存占用就需要200M了，不太可以接受。这时可以选择快排，它的空间复杂度为O(1),但是快排的最好时间复杂度为O(n logn),最坏是O(n2),所以pivot点的选取至关重要，这里我们可以采用三数取中发来决定povit值，也就是取数组的开头、中间和结尾3数进行比较，取最小数作为pivot即可  
3、不管归并和快排都是使用的递归，递归需要警惕栈溢出，我们可以通过控制栈的深度或者改为循坏俩种方式来解决栈溢出的风险。

## TODO

qsort
