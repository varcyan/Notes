# 二叉树

- 非线性表结构 -> 树

? 什么样的二叉树适合用数组来存储： 完全二叉树



**特点**： 支持动态数据集合的快速插入、删除、查找操作。







## 树

![树](https://static001.geekbang.org/resource/image/b7/29/b7043bf29a253bb36221eaec62b2e129.jpg?wh=1142*731)

- 每个元素叫做“节点”
- 节点关系
  - 父节点
  - 子节点
  - 兄弟节点
  - 根节点：没有父节点的节点
  - 叶(子)节点：没有子节点的节点



**相关概念**

- 高度：节点到叶子节点的最长路径（边的个数）
- 深度：根节点到这个节点经历的边的个数
- 层：节点深度 + 1
- 树的高度：根节点的高度



**什么是二叉树**

> 每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。

**满二叉树**：除了叶子节点，每个节点都有左右两个子节点

**完全二叉树**：最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。



## 如何存储一颗二叉树

### 链式存储法

三个字段

- data
- left左指针
- right右指针



### 顺序存储法

![](https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg?wh=1142*604)

i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。



完全二叉树会浪费数组下标为0的位置，非完全二叉树会浪费比较多的数组存储空间。



## 遍历二叉树

- 前序遍历 -> middle - 左 - 右
- 中序遍历 -> 左 - middle - 右
- 后序遍历 ->  左 - 右 -middle



## 二叉查找树

为了实现快速查找。

**特性**

- 支持快速查找、还支持快速插入、删除一个数据
- 中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。

在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

### **查找**  

如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。

```typescript
public class BinarySearchTree {
  private Node tree;

  public Node find(int data) {
    Node p = tree;
    while (p != null) {
      if (data < p.data) p = p.left;
      else if (data > p.data) p = p.right;
      else return p;
    }
    return null;
  }

  public static class Node {
    private int data;
    private Node left;
    private Node right;

    public Node(int data) {
      this.data = data;
    }
  }
}
```

### 插入

如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。

![](https://static001.geekbang.org/resource/image/da/c5/daa9fb557726ee6183c5b80222cfc5c5.jpg?wh=1142*602)

```java
public void insert(int data) {
  if (tree == null) {
    tree = new Node(data);
    return;
  }

  Node p = tree;
  while (p != null) {
    if (data > p.data) {
      if (p.right == null) {
        p.right = new Node(data);
        return;
      }
      p = p.right;
    } else { // data < p.data
      if (p.left == null) {
        p.left = new Node(data);
        return;
      }
      p = p.left;
    }
  }
}
```

### 删除

1. 如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null

2. 如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如删除节点13

3. 如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。

   ![](https://static001.geekbang.org/resource/image/29/2c/299c615bc2e00dc32225f4d9e3490e2c.jpg?wh=1142*620)

### 快速查找最大、最小、前驱、后继节点

- 最大节点：直接向右遍历到底
- 最小节点：直接向左遍历到底
- 前驱节点：当前节点，对其左子树进行向右遍历到底
- 后继节点：当前节点，对其右子树进行向左遍历到底

## 支持重复数据的二叉查找树

**卫星数据**：在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。

key值相同时如何处理？

1. 二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
2. 把这个新插入的数据当作大于这个节点的值来处理。
   1. 查找：遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。
   2. 删除：先查找，再使用二叉查找树的删除方法，依次删除

## TODO
给定一组数据，比如 1，3，5，6，9，10。可以构建出多少种不同的二叉树？
