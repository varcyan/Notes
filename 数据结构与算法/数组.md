# Array

## 定义
数组（Array）是一种**线性表数据**结构。它用一组**连续的内存**空间，来存储一组具有**相同类型的数据**。  

**关键词**  
1. 线性表
2. 连续的内存空间和相同类型的数据
   1. good: 随机访问（随机选择下标进行数据访问
   2. bad: 为了保证连续性，删除、插入数据时，需要做大量的数据搬移工作。

### 线性表
数据排列成线一样的结构；    
只有前后两个方向；  
其他线性表结构：数组、链表、队列、栈。  
### 非线性表
数据之间不是简单的前后关系。  
有：二叉树、堆、图等。

## 关于数组
### 数组是如何实现根据下标访问数组元素的
**base示例**
```
const a = [0,1,2] // 分配一块连续内存空间 100 ~ 111
a[0] // 100 - 103
a[1] // 104 - 107
a[2] // 108 - 111
// base_address = 100
```
**讲解**  
计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：
```
a[i]_address = base_address + i * data_type_size
```
base_address: 内存块的首地址  
data_type_size: 数组中每个元素的大小  

**小结**  
数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。（算法复杂度取决于使用什么方法进行查找）

### 低效的“插入”和“删除”
#### 插入操作
数组长度为n，向数组的第k个位置插入数据。k ~ n 这部分数据需要顺序向后挪一个位置。  
复杂度分析：
1. 最好时间复杂度O(1)，最后一位插入；
2. 最坏时间复杂度O(n)，第一位插入；
3. 平均时间负责度为O(n)；

**更好的做法**
如果数组是没有任何规律的，只被当做一个存储数据的集合。如果需要将某一个数据插入到k位置，可以将原来在k位置的元素搬移到数组末尾，新元素直接放入k的位置。此时时间复杂度为O(1)。
#### 删除操作
和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。
内存的连续性？  
**更好的做法**  
将多次删除操作集中在一起执行。减少其他数据被搬移的次数。  

about: jvm?

### 访问越界


## 小结
访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。  

### 为什么数组要从 0 开始编号，而不是从 1 开始呢？
从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。a[0]是偏移量为0的位置，即首地址。a[k]表示偏移为k个type_size位置
```
a[k]_address = base_address + k * type_size
```
但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：
```
a[k]_address = base_address + (k-1)*type_size
```
**总结**  
1. 多一次减法运算
2. 历史原因

##  get
很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的
# 啊？
内存的连续性？
动态扩容？事先指定数据大小可以省掉很多内存申请和数据搬移操作。  

二维数组内存寻址： 对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址为： address = base_address + ( i * n + j) * type_size

i*n*type_size+j*type_size=（i*n+j）*type_size


## TODO: 快数组和慢数组
