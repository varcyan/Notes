# 复杂度分析
## 定义
**复杂度**也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法**执行效率与数据规模**之间的增长关系。

**时间复杂度**全称是渐进时间复杂度，表示算法的**执行时间与数据规模**之间的增长关系。

**空间复杂度**全称是渐进空间复杂度，表示算法的**存储空间与数据规模**之间的增长关系。

## 为什么需要复杂度分析
**事后统计法**：代码跑一遍通过统计、监控得来执行时间和占用内存大小。

局限性：
1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大

**复杂度分析**不需要具体的数据测试，就可以粗略估算执行效率。

## 时间复杂度
### 大O复杂度表示法
> 并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的**变化趋势**。
它表示的是一个算法执行效率与数据规模增长的变化趋势。

所有代码的执行时间 T(n) 与每行代码的执行次数成正比。公式：
```
T(n) = O(f(n))
```
- T(n): 代码执行时间
- f(n): 每行代码执行次数总和
- O: 代码执行时间T(n)与f(n)表达式成正比

**只需要记录一个最大阶的量级**，公式中低阶?、常量、系数三部分并不左右增长趋势。

### 分析方法
1. 只关注循环执行次数最多的那一段代码就可以了
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

n n^2

### 常见的时间复杂度度示例分析
**多项式量级和非多项式量级**：由数和字母的积组成的代数式叫做单项式，单独的一个数或一个字母也叫做单项式。由若干个单项式相加组成的代数式叫做多项式。

时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常**低效**的算法。

以下是一些多项式时间复杂度：

#### O(1)
```javascript
const a = 1
const b = 2
const c = a + b
```
一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
#### O(logn)、O(nlogn)?
> tips: logarithm-对数

示例
```javascript
 let i = 1;
 while (i <= n)  {
   i = i * 2;
 }
```
分析：每一次循环i*2，也就是i个2相乘。2^i = n, i = log2n. 复杂度是O(log2n)。

不管以几为底，复杂度都记为O(logn)。

O(nlogn)是O(logn)的乘法法则。

**对数相关**：

a^x = b, x是以a为底的b的对数. x = log_a b   a称为底数，b称为真数

？归并排序、快速排序也是O(logn)


#### O(m+n)、O(m*n)
当存在多个数据规模，且无法判断哪个数据规模大的时候，无法直接套用加法法则，需要保留多个数据规模。

一个循环了n次，另一个循环了m次，由于不清楚m和n之间究竟谁大，所以其时间复杂度不能简单地套用加法法则，取其中大的一个。只能认为其时间复杂度是两者的叠加，即m+n。

如果是两段循环代码进行了嵌套，那时间复杂度依然符合乘法法则，复杂度是m*n

### 时间复杂度分析补充
最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）。

### 最好、最坏情况时间复杂度
分析一段代码的时间复杂度
```typescript
function findIndex(arr: any[], x: any): number {
  let result = -1
  const n = arr.length
  for (let i=0; i<n; i++) {
    if (arr[i] === x) result = i
  }
  return result
}
```
这段代码的复杂度是O(n)。n代表数组的长度。

通常我们查找一个数据，不需要把整个数组遍历一遍。因为中途找到就提前结束循环了。

优化代码：
```typescript
function findIndex(arr: any[], x: any): number {
  let result = -1
  const n = arr.length
  for (let i=0; i<n; i++) {
    if (arr[i] === x) {
      result = i
      break // add line
    }
  }
  return result
}
```
优化后，当数组中的第一项刚好是x时，时间复杂度是O(1); 当数组中不存在x时，时间复杂度仍然是O(n)。

因此，不同的情况下，一段代码的时间复杂度是不同的。

### 平均情况时间复杂度？
最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好的表示平均情况复杂度，引入一个概念：**平均时间复杂度**。

#### 示例分析
以上的示例，分两种情况
1. 目标在0 ~ n-1的位置
2. 目标不在数组中

因此，可能存在的所有情况是 n + 1 种。

#### 如何计算
每种情况下需要遍历的次数累加 / 所有的情况 = 平均值

每种情况的次数

1 + 2 + 3 ... + n

找不到的情况遍历的次数

n

所有情况所需要的次数

1 + 2 + 3 ... + n + n

存在的情况

n + 1

(1+2+3....+n+n)／(n+1) = ((n*(n+1)/2)+n)/(n+1) = (n*(n+1)+2n)/(2(n+1)) = (n*(n+3))/(2*(n+1))


 如果查询的元素在第一个，需要遍历一次。在第二位，需要遍历两次。依此类推，第一种情况需要遍历次数为（1+2+3+...+n)次。第二种情况遍历次数为n次。 所以平均时间复杂度为：((1+2+3+...+n) + n)/(n+1) 。即结果为：n(n+3)/2(n+1)。

#### 概率
以上情况没有考虑出现的概率，如果加上概率：

首先能查找到的概率是1/2；如果能查找到，被遍历到的概率是1/n，因为有n个位置，每个位置出现的概率都相同。所以数据被查找到的概率是1/2 * 1/n即1/2n.

这个值就是概率论中的**加权平均值**，也叫作**期望值**，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度

#### 小结
大多数时候不需要使用平均时间复杂度。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。

### 均摊时间复杂度？
均摊时间复杂度就是一种特殊的平均时间复杂度。

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

## 空间复杂度分析
申请空间存储变量

常量阶级的存储可以忽略

申请n大小的数组，空间复杂度是O(n)

## 小结
复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系。

越高阶的复杂度的算法，执行效率越低。

常见的从低到高阶的复杂度：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2 )

CPU在干嘛呢？读数据-运算-写数据

